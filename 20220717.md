## 📘 실용주의 프로그래머

### 5장 구부러지거나 부러지거나(p.193 ~ p.202)

#### 이벤트

**이벤트**는 무언가 정보가 있다는 것을 의미한다. 어디에서 이벤트가 발생한 것이든 애플리케이션을 이런 이벤트에 반응하도록, 그리고 그에 기반해서 하는 일을 조절하도록 만들면, 진짜 세성에서 더 잘 작동되는 애플리케이션이 탄생할 것이다.

어떻게 이벤트에 잘 반응하는 애플리케이션을 만들 수 있을까?

#### 1. 유한 상태 기계(Finite State Machine, FSM)

기본적으로 상태 기계는 이벤트를 어떻게 처리할지 정의한 명세일 뿐이다. 정해진 상태들이 있고 그 중 하나가 '현재 상태'다. 상태마다 그 상태일 대 의미가 있는 이벤트들을 나열하고, 이벤트별로 시스템의 다음 '현재 상태'를 정의한다.

#### 2. 감시자 패턴(Observer Pattern)

감시자 패턴은 이벤트를 발생시키는 쪽인 감시 대상과 이런 이벤트에 관심이 있는 클라이언트인 '감시자'로 이루어진다. '감시자-감시 대상' 패턴은 수십 년간 쓰여 왔고, 잘 동작했다. 특히 사용자 인터페이스 시스템에서 널리 쓰이는데, 어떤 상호작용이 일어났다는 것을 애플리케이션에 콜백으로 알려주는 방식을 사용한다.

하지만 감시자 패턴에는 문제가 하나 있다. 모든 감시자가 감시 대상에 등록을 해야 하기 때문에 결합이 생긴다. 더군다나 일반적으로 감시 대상이 콜백을 직접 호출하도록 구현하기 때문에 이 부분이 성능 병목이 될 수 있다.

#### 3. 게시-구독(Publish-Subscribe)

게시-구독 혹은 발행-구독 모델은 줄여서 펍섭(Pub-Sub)이라고도 부르며 감시자 패턴을 일반화한 것이다. 동시에 감시자 모델의 결합도를 높이는 문제와 성능 문제도 해결한다.

게시-구독 모델에는 '게시자'와 '구독자'가 있고, 이들은 채널로 연결된다. 채널은 별도의 코드로 구현되는데, 라이브러리인 경우도 있고 프로세스 혹은 분산 인프라인 경우도 있다. 이런 상세한 구현 내용은 여러분의 코드로부터 숨겨져 있다.

또한 추가적인 결합 없이 비동기 이벤트 처리를 구현하기에 아주 좋은 기술이다. 다른 기존 코드를 수정하지 않고 이벤트 처리 코드를 추가하거나 교체할 수 있다. 대신 단점은 이 모델을 많이 사용하는 시스템에서는 현재 어떤 일이 벌어지고 있는지 파악하기가 힘들다는 것이다.

### 🤓 느낀점

아직 하나의 방법을 더 읽지는 못하였지만 감시자 패턴과 펍섭 패턴은 그동안 많이 들어왔던 패턴이었다. 이번에 새로 알게 된 것은 FSM인데 기본적으로 이벤트를 처리한다고 생각했을 때 하는 순차적인 생각의 흐름을 가리킨다고 느껴졌다.

책에서 나온 것 처럼 FSM은 개발자들에게 저평가되어 있지만 상태를 외부 저장소에 저장하면서 상태 기계를 동작하면 작업 흐름이 필요한 요구사항을 수월하게 처리할 수 있다. 즉, 모든 이벤트에서 감시자 패턴과 펍섭 패턴을 적용할 필요는 없는 것이다.
흐름대로 작업해도 좋은 경우도 있으니 상황에 따라 패턴을 적용시킬 수 있도록 노력해야겠다.
